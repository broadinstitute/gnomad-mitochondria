#!/usr/bin/env Rscript

library(cowplot)
library(dplyr)
library(ggplot2)
library(grid)
library(optparse)
library(tidyr)
library(stringr)

# Set up directories
option_list = list(
  make_option(c("-s", "--sample_annotations"), type = "character", default = NULL,
              help = "The sample annotations file output by add_annotations.py for release samples", metavar = "character"),
  make_option(c("-u", "--unfiltered_sample_annotations"), type = "character", default = NULL,
              help = "Sample annotations for all, including filtered out samples, only needs to include mt_mean_coverage column", metavar = "character"),
  make_option(c("-v", "--variant_data"), type = "character", default = NULL,
              help = "Combined sites-only file output by add_annotations.py", metavar = "character"),
  make_option(c("-c", "--coverage"), type = "character", default = NULL,
              help = "Mean coverages, tab-delimited file of 'locus', in format of chrM:position, and 'mean', mean coverage across all samples at that position", metavar = "character"),
  make_option(c("-d", "--plot_directory"), type = "character", default = NULL,
              help = "Directory to which plots should be written", metavar = "character"))

opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)

plot_dir <- opt$plot_directory 

min_hom_threshold <- 0.95  # Minimum heteroplasmy level to define a variant as homoplasmic

# Read in sample-level annotations generated by add_annotations.py
data <- read.delim(opt$sample_annotations)
data_unfiltered <- read.delim(opt$unfiltered_sample_annotations)

# Read in mean coverages (tab-delimited file of "locus"	"mean")
mean_cov <- read.delim(opt$coverage)

# Filter to only those samples in the gnomAD release (should already be the case)
gnomad <- filter(data, release == "true")

##############################################################################
# Write table of the number and percentage of samples that fall into each pop
##############################################################################
# Write out a table of the counts/percent totals for each population
pop_counts <- count(gnomad, pop)
pop_counts <- mutate(pop_counts, percent = round(n/sum(n), 3) * 100)
pop_counts_output = paste(plot_dir, "/pop_counts.txt",sep = "")
write.table(pop_counts, pop_counts_output, sep = '\t', row.names = FALSE, quote = FALSE)

##############################################################################
# Write table of coverage and copy number stats
##############################################################################
# Calculate mean/median/min/max coverage and copy number 
cov_stats = gnomad %>%  summarize(mean_mt_mean_coverage = mean(mt_mean_coverage),
                                  median_mean_mt_mean_coverage = median(mt_mean_coverage),
                                  min_mean_mt_mean_coverage = min(mt_mean_coverage),
                                  max_mean_mt_mean_coverage = max(mt_mean_coverage),
                                  median_mito_cn = median(mito_cn),
                                  mean_mito_cn = mean(mito_cn),
                                  median_cp_estimation = median(mito_cn))

cov_stats_output = paste(plot_dir, "/cov_stats.txt", sep = "")
write.table(cov_stats, cov_stats_output, sep = '\t', row.names = FALSE, quote = FALSE)

##############################################################################
# Plot distribution of mean mitochondrial coverage across bases (Fig1A)
##############################################################################
# Redefine upper boundaries for plotting purposes (group values above x into an x+ category)
gnomad <- mutate(gnomad, mito_cn_for_plotting = ifelse(mito_cn >= 800, 800, mito_cn))
gnomad <- mutate(gnomad, mt_mean_coverage_for_plotting = ifelse(mt_mean_coverage >=10000, 10000, mt_mean_coverage))
gnomad <- mutate(gnomad, ndna_coverage_for_plotting = ifelse(wgs_median_coverage >= 60, 60, wgs_median_coverage))
gnomad_unfiltered <- mutate(data_unfiltered, mt_mean_coverage_for_plotting = ifelse(mt_mean_coverage >=20000, 20000, mt_mean_coverage))

median(gnomad_unfiltered$mt_mean_coverage)

# Pull out just the position as it's own column
mean_cov$pos <- as.integer(stringr::str_split_fixed(mean_cov$locus, ":", 2)[,2])

mean_cov_per_base_plot <- ggplot(mean_cov, aes(x = pos, y = mean)) + 
  geom_point(color = "white") +
  geom_line(size = 0.25) +
  theme_bw() +
  theme(axis.text = element_text(size = 14, colour = "black"),
        axis.title = element_text(colour = "black", size = 20, face ="bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm")) +
  scale_x_continuous(limits = c(0, 16569), expand = c(0,0), breaks = c(seq(0, 16569, by = 4000))) +
  labs(x = "mtDNA position", y = "Mean coverage")  
plot(mean_cov_per_base_plot)

setwd(plot_dir)
ggsave(mean_cov_per_base_plot, filename = "Fig1A.png", dpi = 300, width = 11, height = 6, units = "in")
ggsave(mean_cov_per_base_plot, filename = "Fig1A.pdf", dpi = 300, width = 11, height = 6, units = "in")

##############################################################################
# Plot histogram distribution of mean mitochondrial coverage (FigS4A)
##############################################################################
mean_cov_hist_plot <- ggplot(gnomad,aes(x = mt_mean_coverage_for_plotting))+ 
  geom_histogram(binwidth = 100) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, colour = "black"),
        axis.title = element_text(colour = "black", size = 28, face ="bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  scale_x_continuous(limits = c(0, 10000), breaks = c(seq(0, 10000, by = 1000)), labels = c(seq(0, 9000, by = 1000), ">10000")) +
  labs(x = "mtDNA mean coverage", y = "Count")  
plot(mean_cov_hist_plot )

setwd(plot_dir)
ggsave(mean_cov_hist_plot, filename = "FigS4A.png", dpi = 300, width = 11, height = 6, units = "in")
ggsave(mean_cov_hist_plot, filename = "FigS4.pdf", dpi = 300, width = 11, height = 6, units = "in")

##############################################################################
# Plot histogram distribution of mitochondrial copy number estimate (FigS4C)
##############################################################################
cp_hist_plot <- ggplot(gnomad, aes(x = mito_cn_for_plotting))+ 
  geom_histogram(binwidth = 10) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, colour = "black"),
        axis.title = element_text(colour = "black", size = 28, face = "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  scale_x_continuous(limits = c(0, 500), breaks = c(seq(0, 550, by = 100))) +
  labs(x = "mtDNA copy number estimate", y = "Count")  
plot(cp_hist_plot)

setwd(plot_dir)
ggsave(cp_hist_plot, filename = "FigS4C.png", dpi = 300, width = 10, height = 6, units = "in")
ggsave(cp_hist_plot, filename = "FigS4C.pdf", dpi = 300, width = 10, height = 6, units = "in")

##############################################################################
# Plot histogram distribution of nDNA median coverage (FigS4B)
##############################################################################
gnomad <- mutate(gnomad, ndna_coverage_for_plotting = ifelse(wgs_median_coverage >= 60, 60, wgs_median_coverage))

ndna_cov_hist_plot <- ggplot(gnomad, aes(x = ndna_coverage_for_plotting))+ 
  geom_histogram(binwidth = 1) +
  theme_bw() +
  theme(axis.text = element_text(size = 20, colour = "black"),
        axis.title = element_text(colour = "black", size = 28, face = "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  scale_x_continuous(limits = c(0, 60), breaks = c(seq(0, 60, by = 10)), labels = c(seq(0, 50, by = 10), ">60")) +
  labs(x = "nDNA median coverage", y = "Count")  
plot(ndna_cov_hist_plot)

setwd(plot_dir)
ggsave(ndna_cov_hist_plot, filename = "FigS4B.png", dpi = 300, width = 10, height = 6, units = "in")
ggsave(ndna_cov_hist_plot, filename = "FigS4B.pdf", dpi = 300, width = 10, height = 6, units = "in")

##############################################################################
# Make gnomAD metrics dataframe to pull out statistic on number of hets and homs
##############################################################################
# Reformat a new dataframe for the variant metrics
gnomad_metrics <- gather(gnomad, "metric", "value",
                         callrate,
                         mito_cn,
                         n_singletons_het,
                         n_singletons_hom,
                         n_indel_het,
                         n_indel_hom,
                         n_snp_het,
                         n_snp_hom)

# Pull out just the metric for the number of SNPs
gnomad_metrics_snps <- filter(gnomad_metrics, metric == "n_snp_het" | metric == "n_snp_hom")

# Rename levels
gnomad_metrics_snps$metric<- factor(gnomad_metrics_snps$metric,
                                    levels = c("n_snp_het", 
                                               "n_snp_hom"
                                    ),
                                    labels = c("Heteroplasmic", 
                                               "Homoplasmic"
                                    )
)

# Pull out just heteroplasmic SNPs
heteroplasmic_snps <- filter(gnomad_metrics_snps, metric == "Heteroplasmic")
# Pull out just homoplasmic SNPs
homoplasmic_snps <- filter(gnomad_metrics_snps, metric == "Homoplasmic")

##############################################################################
# Set haplogroup colors
##############################################################################
# Set the order for plotting haplogroups
levels = c("L0", "L1", "L5", "L2", "L6", "L4", "L3", "M", "C", "Z", "E", "G", "Q", "D", "N", "I", "W", "Y", "A", "O", "S", "X", "R", "HV", "V", "H", "J", "T", "F", "B", "P", "U", "K")

# Pull out just those haplogroups found in gnomAD and maintain the order
haps_found = unique(gnomad$hap)
haps_found = intersect(levels, haps_found)

# Report if any unexpected haplogroups were found
hap_only_in_data <- setdiff(haps_found, levels)
if (length(hap_only_in_data > 1)) {stop("haplogroups in the data don't match those set in the script")}

# Group haplogroups into high level categories according to mitomap paper
African <- c("L0", "L1", "L5", "L2", "L6", "L4", "L3")
Asian <- c("M", "C", "Z", "E", "G", "Q", "D", "N", "Y", "A", "O", "S", "F", "B", "P")
European <- c("I", "W", "X", "R", "HV", "V", "H", "J", "T", "U", "K")

# Define which colors to use for the high-level haplogroups
african_color <- "red2"
asian_color <- "green3"
european_color <- "blue2"

# Replicate the high-level haplogroup color according to the number of haplogroups in that high-level group
african_colors <- rep(african_color, length(African))
asian_colors <- rep(asian_color, length(Asian))
european_colors <- rep(european_color, length(European))

# Define the plotting order and colors for the haplogroups; use black for the "total" category
haplogroup_order <- c(African, Asian, European, "total")
haplogroup_color_list <- c(african_colors, asian_colors, european_colors, "black")

##############################################################################
# Plot just number of SNPs for heteroplasmic variants (FigS5)
##############################################################################
# Create boxplot of heteroplasmic SNPs
# First generate a category for "total" by duplicating the heteroplasmic_snps dataframe, adding a "total" haplogroup, and rbinding this back onto heteroplasmic_snps
# This method allows the boxplot for each haplogroup to be generated separately as well as across all samples regardless of haplogroup ("total")
heteroplasmic_snps_with_total <- heteroplasmic_snps
heteroplasmic_snps_with_total$hap <- "total" 
heteroplasmic_snps_plot_data <- rbind(heteroplasmic_snps, heteroplasmic_snps_with_total)

heteroplasmic_snps_plot_data <- mutate(heteroplasmic_snps_plot_data, value_for_plotting = ifelse(value >= 5, 5, value))
heteroplasmic_snps_plot <- ggplot(heteroplasmic_snps_plot_data, aes(x = value_for_plotting, y = hap ))+
  geom_boxplot(outlier.size = 0.75) +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.title.x = element_text(size = 11, face = "bold"),
        axis.text.y = element_text(colour = rev(haplogroup_color_list), size = 11),
        axis.text = element_text(colour = "black", size = 11),
        plot.margin = unit(c(0.1, 0.15, 1, 0.75), "cm")) +
  labs(y = "Haplogroup", x = "# Heteroplasmic SNVs\nper sample") +
  scale_y_discrete(limits = rev(haplogroup_order)) +
  scale_x_continuous(position = "top", limits = c(0, 5), breaks = c(seq(0, 5, by = 1)), labels = c(seq(0, 4, by = 1), ">5")) 
heteroplasmic_snps_plot

setwd(plot_dir)
ggsave(heteroplasmic_snps_plot, filename = "FigS5.png", dpi = 300, width = 12, height = 10, units = "in")
ggsave(heteroplasmic_snps_plot, filename = "FigS5.pdf", dpi = 300, width = 12, height = 10, units = "in")

##############################################################################
# Plot just homoplasmic snps per haplogroup (Fig4B)
##############################################################################
# Create boxplot of boxplot of homoplasmic SNPs
# First generate a category for "total" following the same method as used above for heteroplasmic_snps 
homoplasmic_snps_with_total <- homoplasmic_snps
homoplasmic_snps_with_total$hap <- "total" 
homoplasmic_snps_plot_data <- rbind(homoplasmic_snps, homoplasmic_snps_with_total)

# As we want to both set the haplogroup order for plotting and also match the colors of the median bar in the boxplot to the reordered haplogroups,
# we first have to pull out the original order that the haplogroups would have been plotted without ordering
original_plotted_hap_order <- rev(layer_scales(heteroplasmic_snps_plot)$y$range$range)

# Create a new dataframe consisting the of the haplogroups in the original order
original_hap_df <- data.frame(hap = original_plotted_hap_order)

# Assign those haplogroups to the appropriate color based on their high-level haplogroup
original_hap_df <- original_hap_df %>% mutate(original_plotted_hap_color = case_when(.$hap %in% African ~ african_color,
                                                                                     .$hap %in% Asian ~ asian_color,
                                                                                     .$hap %in% European ~ european_color))

# Pull out the colors for the dataframe in the way the haplogroups were originally ordered
original_order_colors = original_hap_df$original_plotted_hap_color

homoplasmic_snps_plot <- ggplot(homoplasmic_snps_plot_data, aes(x = value, y = hap))+
  geom_boxplot(outlier.size = .25,outlier.color = "gray70", lwd =.25) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_text(colour = "black", face = "bold", size = 9),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(colour = "black", size = 8),
        axis.text.y = element_text(colour = rev(haplogroup_color_list), size = 8),
        strip.background = element_blank(),
        strip.text.x = element_text(size = 22, colour = "black",face = "bold")) +
  labs( x= "# Homoplasmic SNVs\nper sample", y = "Number of SNPs") +
  stat_summary(geom = "crossbar", width = 0.65, fatten = 0, color = c(rev(original_order_colors)), fun.data = function(x){ return(c(y = median(x), ymin = median(x), ymax = median(x)))}) +
  scale_y_discrete(limits = rev(haplogroup_order))  +
  scale_x_continuous(position = "top", breaks = seq(0, 100, 50))  
homoplasmic_snps_plot

##############################################################################
# Plot number of heteroplasmies per sample (Fig3D)
##############################################################################
# Add the number of het snps and het indels to get the total number of hets
gnomad <- mutate(gnomad, n_het_total = n_snp_het + n_indel_het)

# Count the number of times each n_het_total occurs
gnomad_hets <- gnomad %>% group_by(n_het_total) %>% summarise(count = n()) %>% ungroup()
gnomad_hets <- mutate(gnomad_hets, percent = count/sum(count)*100)
max(gnomad_hets$n_het_total)

het_histogram <- ggplot(gnomad_hets, aes(x = n_het_total, y = percent)) +
  geom_histogram(stat = "identity") +
  theme_bw() +
  theme(axis.title = element_text(colour = "black", size = 20, face = "bold"),
        axis.text = element_text(colour = "black", size = 14),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  labs(x = "Number heteroplasmies per sample", y = "Percent samples", title = "") 
plot(het_histogram)

setwd(plot_dir)
ggsave(het_histogram, filename ="Fig3D.png", dpi = 300, width = 11, height = 7, units = "in")
ggsave(het_histogram, filename ="Fig3D.pdf", dpi = 300, width = 11, height = 7, units = "in")

########################################################################
########################################################################
# Plot population allele frequencies by category (Fig3B,C)
########################################################################
########################################################################
# Read in the sites-only release data to obtain variant information
variant_data <- read.delim(opt$variant_data)

# Filter to PASS-only variants
variant_data <- filter(variant_data, filters == "[]")

# Convert AFs to percentage
variant_data <- mutate(variant_data, ac = AC_het + AC_hom)
variant_data <- mutate(variant_data, af = ac/AN)
variant_data <- mutate(variant_data, af_percentage = af * 100)

# Group AFs into specific percentage categories to plot singletons, doubletons, and specific AFs
variant_data <- mutate(variant_data, variant_af_group = ifelse(ac == 1,
                                                               "singleton",
                                                               ifelse(ac > 0 & af_percentage < 0.1,
                                                                      "doubleton-0.1%",
                                                                      ifelse(af_percentage >= 0.1 & af_percentage < 1,
                                                                             "0.1-1%",
                                                                             ifelse(af_percentage >= 1 & af_percentage < 10,
                                                                                    "1-10%",
                                                                                    ">10%")))))

# Use max heteroplasmy to determine homoplasmic/heteroplasmic for the plot
# Define homoplasmic and heteroplasmic variants according to min_hom_threshold
variant_data <- mutate(variant_data, variant_level = ifelse(max_hl > min_hom_threshold, "homoplasmic", "heteroplasmic"))

# Count number of variants split by a) AF category, b) homoplasmic or heteroplasmic, c) if haplogroup defining
grouped_counts <- variant_data %>% group_by(variant_af_group, variant_level, hap_defining_variant) %>% summarise(count=n())

# Combine variant level and haplogroup-defining annotations
grouped_counts <- mutate(grouped_counts, variant_group = paste(variant_level, hap_defining_variant, sep = "_"))

# Reformat haplogroup-defining annotation names
grouped_counts$variant_group <- gsub("_true", "\n(haplogroup-defining)", grouped_counts$variant_group)
grouped_counts$variant_group <- gsub("_false", "\n(not haplogroup-defining)", grouped_counts$variant_group)

# Count number of variants split by variant (singleton, doubleton %, etc)
grouped_by_variant <- variant_data %>% group_by(variant_af_group) %>% summarise(count=n()) %>% mutate(proportion = count/sum(count))

# Make barplot for proportion of unique variants falling into each frequency category
pop_af_by_variant_plot <- ggplot(grouped_by_variant, aes(x = variant_af_group, y = proportion)) + 
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(size = 12, colour = "black", angle = 35, hjust = 1),
        axis.text.y = element_text(size = 12, colour = "black"),
        axis.title = element_text(colour = "black", size = 15, face = "bold"),
        axis.title.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.key.size = unit(1.75, 'lines'),
        legend.title = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 1, 0.1), "cm")) +
  scale_fill_manual(values = c("chartreuse4", "chartreuse1", "cadetblue2", "dodgerblue4")) +
  scale_x_discrete(limits = c("singleton", "doubleton-0.1%", "0.1-1%", "1-10%", ">10%")) +
  labs(x = "Percent of samples with variant", y = "Proportion of\nunique variants")
pop_af_by_variant_plot 

# Now add in het/hom and whether or not a haplogroup-defining variant, and plot proportion of each frequency category that falls into these groups
grouped_by_category <- grouped_counts %>% left_join(grouped_by_variant, by = "variant_af_group")
grouped_by_category <- mutate(grouped_by_category, proportion = count.x/count.y)
grouped_by_category$variant_group <- factor(grouped_by_category$variant_group,
                                            levels = c(
                                              "heteroplasmic\n(haplogroup-defining)",
                                              "heteroplasmic\n(not haplogroup-defining)",
                                              "homoplasmic\n(not haplogroup-defining)",
                                              "homoplasmic\n(haplogroup-defining)"
                                            )
)

pop_af_by_category_plot <- ggplot(grouped_by_category, aes(x = variant_af_group, y = proportion, fill = variant_group)) + 
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(size = 12, colour = "black", angle = 35, hjust = 1),
        axis.text.y = element_text(size = 12, colour = "black"),
        axis.title = element_text(colour = "black", size = 15, face = "bold"),
        axis.title.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.key.size = unit(1.75, 'lines'),
        legend.title = element_blank(),
        legend.position = "none",
        plot.margin = unit(c(0.1, 0.1, 1, 0.1), "cm")) +
  scale_fill_manual(values = c("chartreuse4", "chartreuse1", "cadetblue2", "dodgerblue4")) +
  scale_x_discrete(limits = c("singleton", "doubleton-0.1%", "0.1-1%", "1-10%", ">10%")) +
  labs(x = "Percent of samples with variant", y = "Proportion of\ncategory")
pop_af_by_category_plot 

# Replot the same as above, but this time with the legend so that it can be pulled out separately and added to the combined plot
plot_for_legend <- ggplot(grouped_by_category, aes(x = variant_af_group, y = proportion, fill = variant_group)) + 
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(size = 10, colour = "black", angle = 35, hjust = 1),
        axis.text.y = element_text(size = 10, colour = "black"),
        axis.title = element_text(colour = "black", size = 11, face = "bold"),
        axis.title.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.key.size = unit(1.75, 'lines'),
        legend.text=element_text(size = 8),
        legend.title = element_blank(),
        plot.margin = unit(c(5, 5, 5, 5), "cm")) +
  scale_fill_manual(values = c("chartreuse4", "chartreuse1", "cadetblue2", "dodgerblue4")) +
  scale_x_discrete(limits = c("singleton", "doubleton-0.1%", "0.1-1%", "1-10%", ">10%")) +
  labs(x = "Percent of samples with variant", y = "Proportion of\ncategory")
plot_for_legend 

# Combine the pop af and freq category plots
combined_plot <- plot_grid(pop_af_by_variant_plot, pop_af_by_category_plot)
# Grab just the legend
legend_b <- get_legend(plot_for_legend  + 
                         theme(legend.justification="center", 
                               legend.box.just = "bottom",
                               legend.box.margin = unit(c(0, 0, 2.75, 0), "cm")))

# Combine the two plots and the legend
combined_plot <- plot_grid(combined_plot, legend_b, rel_widths = c(3, 1.5), rel_heights = c(2, 1))

combined_plot <- combined_plot + draw_label("Percent of samples with variant", x = 0.40, y = 0.01, hjust = 0.5, vjust = -1,
                                            fontfamily = "", fontface = "bold", colour = "black", size = 16,
                                            lineheight = 0.9, alpha = 1) 
combined_plot

setwd(plot_dir)
ggsave(combined_plot, filename = "Fig3BC.png", dpi = 300, width = 7, height = 4, units = "in")
ggsave(combined_plot, filename = "Fig3BC.pdf", dpi = 300, width = 7, height = 4, units = "in")

########################################################################
########################################################################
# Heatmap for percent of each population belonging to each haplogroup (Fig4D)
########################################################################
########################################################################
# Calculate the percent of each populations made up of each haplogroup
hap_pop <- select(data, hap, pop)
hap_sums <- data %>% group_by(hap) %>% summarise(hap_count = n())
pop_sums <- data %>% group_by(pop) %>% summarise(pop_count = n())
pop_sums <- mutate(pop_sums, percent = round(pop_count/sum(pop_count) * 100, 0))
hap_pop <- hap_pop %>% group_by(hap, pop) %>% summarise(count = n())
hap_pop <- left_join(hap_pop, hap_sums, by = "hap") %>% ungroup() 

# Finding missing haplgroups
missing_haps <- setdiff(levels, unique(hap_pop$hap))
for(h in missing_haps) {for(p in unique(hap_pop$pop)){hap_pop <- hap_pop %>% add_row(hap = h, pop = p, count = NA)}}

# Remove total category and get complete df of all pop and haplogroup combinations
hap_pop = filter(hap_pop, hap != "total")
hap_pop <- complete(hap_pop, hap, pop)
hap_pop <- mutate(hap_pop, percent = round(count/hap_count*100, 0))

hap_sums <- mutate(hap_sums, total = "total") %>% ungroup()
# Add a row for each missing haplgroup and set the total to NA
for(h in missing_haps) {hap_sums <- hap_sums %>% add_row(hap = h, hap_count = NA, total = "total")}
hap_sums <- hap_sums %>% add_row(hap = "total", hap_count = sum(hap_sums$hap_count, na.rm = TRUE), total = "total")

# Need to add "empty "total" haplogroup to main df
hap_pop_data <- bind_rows(hap_pop, pop_sums)
# If haplgroup is "NA", set that haplogroup to "total" (keeping track of population totals)
hap_pop_data <- mutate(hap_pop_data, hap = ifelse(is.na(hap), "total", hap))

pop_abbreviations <- c("nfe", "afr", "amr", "fin", "eas", "sas", "asj", "ami", "mid", "oth")
pop_full_names <- c("Non-finnish\nEuropean", "African/African\nAmerican", "Latino", "Finnish", "East\nAsian", "South\nAsian", "Ashkenazi\nJewish", "Amish", "Middle\nEastern", "Other")
# Set the order for populations
pop_order <- c(
  "African/African\nAmerican", 
  "Non-finnish\nEuropean",
  "Finnish",
  "Amish",
  "Ashkenazi\nJewish",
  "Middle\nEastern",
  "South\nAsian",
  "East\nAsian", 
  "Latino",
  "Other")

# Expand abbreviated population names to their full names and order them 
hap_pop_data$pop <- factor(hap_pop_data$pop,
                           levels = pop_abbreviations,
                           labels = pop_full_names)

heatmap_hap_pop <- ggplot(hap_pop_data, aes(x = pop, y = hap, fill = percent)) + 
  geom_tile() +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(colour = "black", angle=45, vjust = 0, hjust = 0, size = 8),
    axis.text.y = element_text(colour = rev(haplogroup_color_list), size = 8),
    axis.title = element_text(colour = "black", face = "bold"),
    axis.title.y = element_text(size = 8, color = "white"),
    axis.ticks.y = element_blank(),
    legend.position = "none") +
  scale_y_discrete(limits = rev(haplogroup_order))  +
  scale_x_discrete(position = "top", limits = pop_order) +
  geom_text(size = 2.75, fontface = 'bold', aes(pop, hap, label = ifelse(is.na(percent), "-", percent))) +
  scale_fill_gradient2(low = "gray85", high = "gray75", na.value = "white") +
  labs(x = "Haplogroup by nuclear ancestry (%)", fill = "Percent")
heatmap_hap_pop

# Get the indexes of haplogroups in decreasing order of their counts
# Second value is the haplogroup with the highest count (will want this to be the darkest in the heatmap); first value is for "total"
index <- order(hap_sums$hap_count, decreasing = T)[2:2]
biggest_hap_count <- hap_sums$hap_count[index]

########################################################################
########################################################################
# Plot number of sample belonging to each haplogroup (Fig4A)
########################################################################
########################################################################
heatmap_hap <- ggplot(hap_sums, aes(x = total, y = hap, fill = hap_count)) + 
  geom_tile() +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        axis.title.y = element_text(colour = "black", face = "bold"),
        axis.title.x = element_text(colour = "black", face = "bold",size = 9),
        axis.text.y = element_text(colour = rev(haplogroup_color_list), size = 8),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_y_discrete(limits = rev(haplogroup_order)) +
  scale_x_discrete(position = "top") +
  theme(legend.position = "none") +
  geom_text(size = 2.75, fontface ='bold', aes(total, hap, label = ifelse(is.na(hap_count), "-", hap_count)))  +
  scale_fill_gradient2(low = "gray85", high = "gray75", na.value = "white", limits = c(0, biggest_hap_count))  +
  labs(y ="mtDNA haplogroup", x = "#\n Samples")
heatmap_hap 

########################################################################
########################################################################
# Plot bar graph of proportion mtDNA ancestry in each population (Fig4F)
########################################################################
########################################################################
# Use full population labels
data$population <- factor(data$pop,
                          levels = pop_abbreviations,
                          labels = pop_full_names)

unique(hap_pop_data$pop)
hap_pop_data$pop <- factor(hap_pop_data$pop,
                           levels = pop_abbreviations,
                           labels = pop_full_names)

# Calculate proportion of population that is in each haplgroup
grouped_data <- data %>% group_by(population, hap) %>% summarise(count = n()) %>% mutate(proportion = count/sum(count))
# Group haplogroups into 3 high level groups (African, Asian, European)
data_alt <- mutate(data, super_haplogroup = if_else(hap %in% African,"African", if_else(hap %in% Asian, "Asian", if_else(hap %in% European, "European", "NA"))))
# Regroup data by both population and above redefined high level haplogroups
grouped_data_alt <- data_alt %>% group_by(population, super_haplogroup) %>% summarise(count = n()) %>% mutate(proportion = count/sum(count))
# Set the haplogroup colors to use for plotting
data_alt <- data_alt %>% mutate(superhap_color = case_when(.$super_haplogroup == "African" ~ african_color,
                                                           .$super_haplogroup == "Asian" ~ asian_color,
                                                           .$super_haplogroup == "European" ~ european_color))

hap_pop_hist_by_pop <- ggplot(grouped_data_alt, aes(x = population, y = proportion, fill = super_haplogroup)) + 
  geom_histogram(stat = "identity") +
  theme_bw() +
  theme(axis.title = element_text(colour = "black", size = 9, face = "bold"),
        axis.title.x = element_blank(),
        axis.text = element_text(colour = "black", size = 8, hjust = 1),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_text(size = 9),
        legend.position = "bottom") +
  scale_fill_manual(values = setNames(data_alt$superhap_color, data_alt$super_haplogroup)) +
  scale_x_discrete(limits = pop_order) +
  labs(y = "Proportion of\nnuclear ancestry\nby mtDNA ancestry", title = "", fill = "mtDNA ancestry:")
plot(hap_pop_hist_by_pop)

########################################################################
########################################################################
# Plot bar graph of proportion population in each mtDNA ancestry (Fig4C)
########################################################################
########################################################################
# Add in "total" category to data
data_with_total <- data
data_with_total$hap <- "total" 
data <- rbind(data, data_with_total)

# Define colors of the populations
afr_pop_color <- "#941494"
ami_pop_color <- "#FFC0CB"
amr_pop_color <- "#ED1E24"
asj_pop_color <- "#FF7F50"
eas_pop_color <- "#108C44"
fin_pop_color <- "#002F6C"
mid_pop_color <- "#33CC33"
nfe_pop_color <- "#6AA5CD"
oth_pop_color <- "#ABB9B9"
sas_pop_color <- "#FF9912"

# Calculate proportion of haplogroups that is in each population
grouped_data_alt <- data %>% group_by(hap, pop) %>% summarise(count = n()) %>% mutate(proportion = count/sum(count))
# Set the colors for each population
grouped_data_alt <- grouped_data_alt  %>% ungroup() %>% mutate(pop_color=case_when(.$pop == "afr" ~ afr_pop_color,
                                                                                   .$pop == "ami" ~ ami_pop_color,
                                                                                   .$pop == "amr" ~ amr_pop_color,
                                                                                   .$pop == "asj" ~ asj_pop_color,
                                                                                   .$pop == "eas" ~ eas_pop_color,
                                                                                   .$pop == "fin" ~ fin_pop_color,
                                                                                   .$pop == "mid" ~ mid_pop_color,
                                                                                   .$pop == "nfe" ~ nfe_pop_color,
                                                                                   .$pop == "oth" ~ oth_pop_color,
                                                                                   .$pop == "sas" ~ sas_pop_color))
# Set the order of the populations specifically for this plot
grouped_data_alt$pop<- factor(grouped_data_alt$pop, levels = c("oth", "amr", "eas", "sas", "mid", "asj", "ami", "fin", "nfe", "afr"))

hap_pop_hist_by_hap <- ggplot(grouped_data_alt, aes(x = proportion, y = hap, fill = pop)) + 
  geom_histogram(stat = "identity") +
  theme_bw() +
  theme(axis.title = element_text(colour = "black", size = 9, face = "bold"),
        axis.title.y = element_blank(),
        axis.text = element_text(colour = "black", size = 8),
        axis.text.y = element_text(colour = rev(haplogroup_color_list)),
        axis.ticks.y = element_blank(),
        legend.title = element_text(size = 11),
        legend.text = element_text(size = 11),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_discrete(limits = rev(haplogroup_order))  +
  scale_x_continuous(position = "top", breaks = c(0.0, 1.00, 0.50)) +
  scale_fill_manual(values = setNames(grouped_data_alt$pop_color, grouped_data_alt$pop)) +
  labs(x = "Population of haplogroup\nby nuclear ancestry", y = "Haplogroup", title = "", fill= "Population")
plot(hap_pop_hist_by_hap)

########################################################################
########################################################################
# Plot bar graph for showing number of samples in each population (Fig4E)
########################################################################
########################################################################
pop_sums$population <- factor(pop_sums$pop,
                              levels = pop_abbreviations,
                              labels = pop_full_names)

pop_sums  <- pop_sums  %>% mutate(pop_color=case_when(.$pop == "afr" ~ afr_pop_color,
                                                      .$pop == "ami" ~ ami_pop_color,
                                                      .$pop == "amr" ~ amr_pop_color,
                                                      .$pop == "asj" ~ asj_pop_color,
                                                      .$pop == "eas" ~ eas_pop_color,
                                                      .$pop == "fin" ~ fin_pop_color,
                                                      .$pop == "mid" ~ mid_pop_color,
                                                      .$pop == "nfe" ~ nfe_pop_color,
                                                      .$pop == "oth" ~ oth_pop_color,
                                                      .$pop == "sas" ~ sas_pop_color))

hist_pop_counts <- ggplot(pop_sums, aes(y = pop_count, x = population, fill = population)) + 
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.title.y = element_text(colour = "black", face = "bold", size = 9),
        axis.title.x = element_blank(),
        axis.text.x = element_text(colour = "black", angle = 45, vjust = 0.5, size = 8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_y_continuous(limits = c(0, max(pop_sums$pop_count) + .10*max(pop_sums$pop_count))) +
  scale_x_discrete(limits = pop_order) +
  geom_text(aes(label = scales::comma(pop_count)), position = position_dodge(width = 0.9), vjust = -0.25, size = 2.5) +
  scale_fill_manual(values = setNames(pop_sums$pop_color, pop_sums$population)) +
  theme(legend.position = "none")  +
  labs(y = "# Samples")
hist_pop_counts

########################################################################
########################################################################
# Combine plots for Fig4
########################################################################
########################################################################
# Combine plots for Fig4 A,B,C,D for the top panel of the overall figure
combined_plot1a <- plot_grid(heatmap_hap, homoplasmic_snps_plot, hap_pop_hist_by_hap, heatmap_hap_pop, ncol = 4, align = 'h', rel_widths = c(1, 2, 2, 5), labels = c('A', 'B', 'C', 'D'))

# Combine plots for Fig4 E,F for the top panel of the overall figure
combined_plot1b <- plot_grid(hist_pop_counts, hap_pop_hist_by_pop, ncol = 2, axis = "bt", align = 'h', rel_widths = c(1, 1.130), labels = c('E', 'F'))

# Combine the top and bottom panels for Fig4
combined_plot1c <- plot_grid(combined_plot1a, combined_plot1b, ncol = 1, rel_heights = c(2,1))

setwd(plot_dir)
ggsave(combined_plot1c, filename = "Fig4.png", dpi = 300, width = 10, height = 7, units = "in")
ggsave(combined_plot1c, filename = "Fig4.pdf", dpi = 300, width = 10, height = 7, units = "in")

